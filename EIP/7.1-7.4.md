# 7.1 Interconvert Strings and Integers
A string is a sequence of characters. A string may encode an integer, e.g., "123" encodes 123. In this problem, you are to implement methods that take a string representing an integer and return the corresponding integer, and vice versa. Your code should handle negative integers. You cannot use library functions like `stoi` in C++ or `parseInt` in Java.

Implement string/integer inter-conversion functions.

_Hint: Build the result one digit at a time._

## My Solution
```C++
long int my_stoi (string s) {
	long int acc = 0;
	long int pow10 = 1;
	int i = 0;
	for (auto itr = s.rbegin();
		 i < s.size() + (s.front() == '-' ? -1 : 0);
		 ++itr) {
		acc += int(*itr - '0') * pow10;
		pow10 *= 10;
		++i;
	}
	if (s.front() == '-') acc *= -1;
	return acc;
}

string my_itos (long int i) {
	string s;
	if (i == 0) return "0";
	bool neg = false;
	if (i < 0) { i *= -1; neg = true; }
	while (i) {
		s.push_back((i % 10) + '0');
		i /= 10;
	}
	if (neg) { s.push_back('-'); }
	reverse(s.begin(), s.end());
	return s;
}
```

## Book Solution
```C++
int StringToInt (const string& s) {
	bool is_negative = s[0] == '-';
	int result = 0;
	for (int i = s[0] == '-' ? 1 : 0; i < s.size(); ++i) {
		int digit = s[i] - '0';
		result = result * 10 + digit;
	}
	return is_negative ? -result : result;
}

string IntToString (int x) {
	bool is_negative = false;
	if (x < 0) { x = -x; is_negative = true; }

	string s;
	do {
		s += '0' + x % 10;
		x /= 10;
	} while (x);

	if (is_negative) { s += '-'; }

	reverse(s.begin(), s.end());
	return s;
}
```


# 7.2 Replace and Remove
Consider the following two rules that are to be applied to strings over the alphabets `{'a', 'b', 'c', 'd'}`.

1. Replace each `'a'` by `"dd"`.
2. Delete each `'b'`.

It is straightforward to implement a function that takes a string `s` as an argument, and apply these rules to `s` if the function can allocate `O(n)` additional storage, where `n` is the length of `s`.

Write a program which takes as input a string `s`, and removes each `'b'` and replaces each `'a'` by `"dd"`. Assume `s` is stored in an array that has enough space for the final result.

_Hint: Consider performing multiple passes on `s`._

## My Solution
```C++
// O(n) time & O(n) space
void Problem7_2_1 (string& s) {
	string tmp;
	for (char c : s) {
		// Rule 1
		if (c == 'a') { tmp += 'd'; tmp += 'd'; }
		// Rule 2
		else if (c != 'b') tmp += c;
	}
	copy(tmp.begin(), tmp.end(), s.begin());
	s.resize(tmp.size());
}

// O(n) time and O(1) space
void Problem7_2_2 (string& s) {
	// fwd iter: remove 'b's and count 'a's
	int i = 0, num_a = 0;
	for (const char &c : s) {
		if (c != 'b') s[i++] = c;
		if (c == 'a') num_a++;
	}
	// allocate enough space for new s
	s.resize(i + num_a);
	// bkwd iter: replace 'a's with "dd"s, starting from end
	i--;
	int j = s.size() - 1;
	while (i) {
		if (s[j] == 'a') {
			s[j--] = 'd';
			s[j--] = 'd';
		} else
			s[j--] = s[i];
		i--;
	}
}
```

## Book Solution
string ReplaceAndRemove (string s) {
	// Forward Iteration: remove "b"s and count number of "a"s
	int write_idx = 0, a_count = 0;
	for (const char &c : s) {
		if (c != 'b') s[write_idx++] = c;
		if (c == 'a') ++a_count;
	}

	// allocate space according to number of 'a'
	s.resize(write_idx + a_count);
	// backward iteration: replace "a"s with "dd"s starting from end
	int cur_idx = write_idx - 1;
	write_idx = s.size() - 1;
	while (cur_idx >= 0) {
		if (s[cur_idx] == 'a') {
			s[write_idx--] = 'd';
			s[wirte_idx--] = 'd';
		} else
			s[write_idx--] = s[cur_idx];
		--cur_idx;
	}
	return s;
}

# 7.3 Test Palindromicity
For the purpose of this problem, define a palindromic string to be a string which when all the non-alphanumerics are removed it reads the same front to back ignoring case. For example, "A man, a plan, a canal, Panama." and "Able was I, ere I saw Elba!" are palindromic, but "Ray a Ray" is not.

Implement a function which takes as input a string `s` and returns `true` if `s` is a palindromic string.

_Hint: Use two indices._

## My Solution
```C++
bool IsPalindrome (string const& s) {
	size_t const n = s.size();
	size_t left = 0, right = n - 1;
	while (left < right) {
		while (left < n && !IsAlphanumeric(s[left])) { ++left; }
		while (right && !IsAlphanumeric(s[right])) { --right; }

		if (left >= n || right < 0 ||
			Lowercase(s[left]) != Lowercase(s[right])) return false;
		++left; --right;
	}
	return true;
}
```

# 7.4 Reverse all the words in a sentence
Given a string containing a set of words separated by whitespace, we would like to transform it to a string in which the words appear in the reverse order. For example, "Alice likes Bob" transforms to "Bob likes Alice". We do not need to keep the original string.

Implement a function for reversing the words in a string `s`.

_Hint: It's difficult to solve this with one pass._

## My Solution
```C++
void ReverseSentence (string& s) {
	// add space to end of s if not there
	if (s.back() != ' ') s += ' ';
	// count number of words
	int num_words = 1;
	for (char const& c : s)
		if (c == ' ') num_words++;

	ReverseSentence(s, num_words, 0, s.size()-1);

	// remove last space
	s = s.substr(0, s.size() - 1);  // ?
}

void ReverseSentence (string& s, int num_words, size_t lo, size_t hi) {
	if (IsOdd(num_words)) {
		// exclude middle word
		size_t lo_exclude, hi_exclude;
		FindMiddle(s, num_words, lo, hi, &lo_exclude, &hi_exclude);
		ReverseSentence(s, num_words / 2, lo, lo_exclude-1);
		ReverseSentence(s, num_words / 2, hi_exclude+1, hi);
		SwapRegions(s, num_words / 2, lo, lo_exclude-1, hi_exclude+1, hi);
	} else {  // even
		SwapRegions(s, num_words / 2, lo, num_words / 2 - 1,
					num_words / 2, hi);
		ReverseSentence(s, num_words / 2, lo, num_words / 2 - 1);
		ReverseSentence(s, num_words / 2, num_words / 2, hi);
	}
}
```

This is too complicated. Let's find an easier way.

```C++
void ReverseSentence (string& s) {  // "ram is costly"
	// Reverse the whole sentence
	reverse(s.begin(), s.end());  // "yltsoc si mar"

	// Reverse each word in the sentence
	size_t lo_word = 0, hi_word;
	size_t const n = s.size();
	for (size_t i = 0; i < n; i++) {
		if (s[i] == ' ') {
			reverse(s.begin()+lo_word, s.begin()+i);
			lo_word = i + 1;
		}
	}
	// We forgot to reverse the last word
	reverse(s.begin()+lo_word, s.end());
}
```
