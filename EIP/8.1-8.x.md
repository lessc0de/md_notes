# 8.1 Merge two sorted lists
Let `L` and `F` be singly linked lists in which each node holds a number. Assume the numbers in `L` and `F` appear in ascending order within the lists. The _merge_ of `L` and `F` is a list consisting of the nodes of `L` and `F` in which numbers appear in ascending order.

Write a program that takes `L` and `F`, and returns the merge of `L` and `F`. Your code should reuse the nodes from the lists provided as input. Your program should use `O(1)` additional storage. The only field you can change in a node is `next`.

_Hint: Two sorted arrays can be merged using two indices. For lists, take care when one iterator reaches the end._

## My Solution
```C++
#include <memory>
using namespace std;

template <typename T>
struct ListNode {
	T data;
	shared_ptr<ListNode<T> > next;
};

template <typename T>
auto Merge (shared_ptr<ListNode<T> > pF, shared_ptr<ListNode<T> > pL) {
	shared_ptr<ListNode<T> > traverser, opposite, head;
	if (pF->data < pL->data) {
		traverser = pF;
		opposite = pL;
	} else {
		traverser = pL;
		opposite = pF;
	}

	head = traverser;

	while (traverser->next) {
		if (opposite->data < traverser->next->data) {
			auto tmp = traverser->next;
			traverser->next = opposite;
			traverser = opposite;
			opposite = tmp;
		} else
			traverser = traverser->next;
	}

	traverser->next = opposite;
	return head;
}
```

The solution is `O(n + m)`, where `n` is the size of `L`, and `m` is the size of `F`.

## Book Solution
```C++
template <typename T>
shared_ptr<ListNode<T>> MergeTwoSortedLists (shared_ptr<ListNode<T>> L,
											 shared_ptr<ListNode<T>> F) {
	// Create a placeholder for the result
	shared_ptr<ListNode<T>> dummy_head(new ListNode<int>);
	auto tail = dummy_head;

	while (F && L) {
		AppendNode(F->data < L->data ? &F : &L, &tail);
	}

	// Appends the remaining nodes of F or L
	tail->next = F ? F : L;

	return dummy_head->next;
}

template <typename T>
void AppendNode (shared_ptr<ListNode<T>>* node, shared_ptr<ListNode<T>>* tail) {
	(*tail)->next = *node;
	*tail = *node;  // updates tail
	*node = (*node)->next;
}
```

# 8.2 Reverse a singly linked list
Suppose you were given a singly linked list `L` of integers sorted in ascending order and you need to return a list with the elements sorted in descending order. Memory is scarce, but you can reuse nodes in the original list, i.e., your function can change `L`.

Give a linear time non-recursive function that reverses a singly linked list. The function should use no more than constant storage beyond that needed for the list itself.

_Hint: Use a pair of iterators._

## My Solution
```
f->next = t (1)
s->next = h (2)
h = s 		(3)
s = t       (4)
t = s->next (5)
hf   s    t
0 -> 1 -> 2 -> 3 -/

s    hf   t
h    f    s    t
1 -> 0 -> 2 -> 3 -/

s    h    f    t
h         f    s  t
2 -> 1 -> 0 -> 3 -/

s    h         f  t
h              f  s  t?
3 -> 2 -> 1 -> 0 -/

hf   s  t
0 -> 1 -/

s    hf t
h	 f  st
1 -> 0 -/
```

```C++
auto ReverseList (shared_ptr<LinkedList<int>> pL) {
	// quit if pL is size 1
	if (!pL->next) return;
	auto h = pL,
		 f = pL,
		 s = h->next,
		 t = pL;  // dummy starting value to enter while loop
	while (t) {
		t = s->next;
		f->next = t;
		s->next = h;
		h = s;
		s = t;
	}
	return h;
}
```

## Book Solution
```C++
shared_ptr<ListNode<int>> ReverseLinkedList (
	shared_ptr<ListNode<int>> const& head)
{
	shared_ptr<ListNode<int>> prev = nullptr, curr = head;
	while (curr) {
		auto next = curr->next;
		curr->next = prev;
		prev = curr;
		curr = next;
	}
	return prev;
}
```

Both solutions are `O(1)` storage and linear time. However, the book solution is simpler...

# 8.3 Reverse a single sublist
This problem is concerned with reversing a sublist within a list.

Write a program which takes a singly linked list `L` and two integers `s` and `f` as arguments, and reverses the order of the nodes from the `s`-th node to the `f`-th node, inclusive. The number begins at 1, i.e., the head node is the first node. Perform the reversal in a single pass. Do not allocate additional nodes.

_Hint: Focus on the successor fields which have to be updated._

## My Solution
```
     h
a -> 0 -> 1 -> b
   h    l
/- 0 <- 1/a  b
a -> 1 -> 0 -> b
```

```C++
template <typename T>
void ReverseSubList (shared_ptr<LinkedList<T>> pL, int s, int f) {
	if (s >= f) return;
	// navigate to lo_exc
	shared_ptr<ListNode<T>> lo_exc(nullptr);
	int n = f - s;
	for (int i = 1; i < s; i++) {
		if (i == 1) lo_exc = pL;
		else lo_exc = lo_exc->next; 
	}

	// reverse s -> f
	shared_ptr<LinkedList<T>> hi = lo_exc->next;
	shared_ptr<LinkedList<T> hi_exc, lo;
	shared_ptr<LinkedList<T>> prev = nullptr, curr = hi;
	for (int i = s; s <= f; i++) {
		auto next = curr->next;
		if (s == f) {
			lo = curr;
			hi_exc = next;	
		}
		curr->next = prev;
		prev = curr;
		curr = next;
	}

	// point lo_exc to lo & hi to hi_exc
	if (lo_exc) lo_exc->next = lo;
	hi->next = hi_exc;
}
```

## Book Solution
```C++
shared_ptr<ListNode<int>> ReverseSubList (shared_ptr<ListNode<int>> L,
	int start, int finish)
{
	if (start == finish) return L;

	auto dummy_head = make_shared<ListNode<int>>(ListNode<int>{0, L});
	auto sublist_head = dummy_head;
	int k = 1;
	while (k++ < start) {
		sublist_head = sublist_head->next;
	}

	// reverses sublist
	auto sublist_iter = sublist_head->next;
	while (start++ < finish) {
		auto temp = sublist_iter->next;
		sublist_iter->next = temp->next;
		temp->next = sublist_head->next;
		sublist_head->next = temp;
	}
	return dummy_head->next;
}
```


# 8.4 Reverse sublists `k` at a time
This problem entails reversing sublists of a given singly linked list `k` at a time.

Write a program which takes as input a singly linked list `L` and a non-negative integer `k`, and reverses the list `k` nodes at a time. If the number of nodes `n` in the list is not a multiple of `k`, leave the last `n` mod `k` nodes unchanged. Do not change the data stored within a node.

_Hint: Perform case analysis._

## My Solution
```
0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -/
0 -> 7 -> 2 -> 5 -> 4 -> 3 -> 6 -> 1 -> 8 -/
```

```C++
template <typename T>
void ReverseListByK (shared_ptr<ListNode<T>> pL, int k) {
	if (k == 1) return;
	auto a = pL, b = pL;
	while (true) {
		for (int i = 1; i <= k; i++) {
			if (!b) return;
			b = b->next;
		}
		ReverseSubList(a, 1, k);
		a = b;
	}
}
```

Time complexity is `O(n)`.

## Book Solution
The basic idea is straightforward -- use Solution 8.2 to reverse the sublist consisting of the first `k` nodes, then the sublist of the next `k` nodes, etc. The new head of the reversed sublist must be made the successor of the tail of the previous sublist. We use two iterators, one for the head and one for the tail of the sublist being reversed. The implementation requires additional variables to record the nodes adjacent to the sublist.

```C++
shared_ptr<ListNode<int>> ReverseK (shared_ptr<ListNode<int>> L, int k) {
	auto dummy_head = make_shared<ListNode<int>>(ListNode<int>{0, L});
	shared_ptr<ListNode<int>> sublist_predecessor = dummy_head,
							  sublist_head = dummy_head->next,
							  sublist_successor = dummy_head,
							  sublist_tail = dummy_head->next;
	while (sublist_head) {
		// Identify the tail of the sublist of k nodes to be reversed
		int num_remaining = k;
		while (num_remaining) {
			sublist_successor = sublist_tail;
			sublist_tail = sublist_tail->next;
			--num_remaining;
			if (!sublist_tail) break;
		}
		if (num_remaining > 0) return dummy_head->next;

		sublist_successor->next = nullptr;
		ReverseLinkedList(sublist_head);

		// splice the reversed sublist
		sublist_predecessor->next = sublist_successor;
		// go on to the head of next sublist
		sublist_predecessor = sublist_head, sublist_head->next = sublist_tail;
		sublist_head = sublist_tail, sublist_successor = nullptr;
	}
	return dummy_head->next;
}
```

# 8.5 Test for cyclicity
Although a linked list is supposed to be a sequence of nodes ending in a `null`, it is possible to create a cycle in a linked list by making the next field of an element reference to one of the earlier nodes.

Given a reference to the head of a singly linked list, how would you determin whether the list ends in a `null` or reaches a cycle of nodes? Write a program that returns `null` if there does not exist a cycle, and the reference to the start of the cycle if a cycle is present. (You do not know the length of the list in advance).

_Hint: Consider using two iterators, one fast and one slow._

## My Solution
This is an `O(n^2)` solution:
```C++
template <typename T>
shared_ptr<ListNode<T>> CycleCheck (shared_ptr<ListNode<T>> pL) {
	int i = 1;
	auto itr_i = pL->next;
	shared_ptr<ListNode<T>> ans = nullptr;
	while (itr_i) {
		auto itr_j = pL;
		for (int j = 0; j < i; j++) {
			if (itr_j == itr_i) { ans = itr_j; break; }
			itr_j = itr_j->next;
		}
		i++;
		itr_i = itr_i->next;
	}
	return ans;
}
```

Notice that we don't have to recheck many answers:
```
0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 3 -> ...
1: 0 -> 1
2: 1 -> 2 -> 3
3: 3 -> 4 -> 5 -> 6
4: 6 -> 7 -> 3 -> 4

0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 3 -> ...
0: 0 -> 1
1: 1 -> 2 -> 3
2: 3 -> 4 -> 5 -> 6
3: 6 -> 7 -> 8 -> 3

0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 2 -> ...
0: 0 -> 1
1: 1 -> 2 -> 3
2: 3 -> 4 -> 5 -> 6
3: 6 -> 7 -> 8 -> 2
4: 2 -> 3 -> 4
```

```C++
template <typename T>
shared_ptr<ListNode<T>> CycleCheck (shared_ptr<ListNode<T>> pL) {
	int i = 1;
	auto fast_itr = pL,
		 slow_itr = pL;
	bool break_while = false;
	while (!break_while) {
		for (int j = 0; j <= i; j++) {
			if (fast_itr->next == slow_itr) {
				break_while = true;
				break;  // for-loop
			} else fast_itr = fast_itr->next;
		}
		i++;
		slow_itr = slow_itr->next;
	}
	// count cycle length
	int cycle_length = 1;
	auto itr = fast_itr->next;
	while (itr != fast_itr) {
		itr = itr->next;
		cycle_length++;
	}

	// place two itrs cycle_length away and update both
	// until they both equal each other
	auto itr1 = pL, itr2 = pL;
	for (int i = 0; i < cycle_length; i++)
	while (itr1 != itr2) {
		itr1 = itr1->next;
		itr2 = itr2->next;
	}

	return itr1;
}
```

