# 8.1 Merge two sorted lists
Let `L` and `F` be singly linked lists in which each node holds a number. Assume the numbers in `L` and `F` appear in ascending order within the lists. The _merge_ of `L` and `F` is a list consisting of the nodes of `L` and `F` in which numbers appear in ascending order.

Write a program that takes `L` and `F`, and returns the merge of `L` and `F`. Your code should reuse the nodes from the lists provided as input. Your program should use `O(1)` additional storage. The only field you can change in a node is `next`.

_Hint: Two sorted arrays can be merged using two indices. For lists, take care when one iterator reaches the end._

## My Solution
```C++
#include <memory>
#include <iostream>
#include <cassert>

using namespace std;

template <typename T>
struct ListNode {
	T data;
	shared_ptr<ListNode<T> > next;
};

template <typename T>
auto new_list_node (T data, shared_ptr<ListNode<T> > next) {
	auto ln = new ListNode<T>;
	ln->data = data;
	ln->next = next;
	return ln;
}

template <typename T>
auto Merge (shared_ptr<ListNode<T> > pF, shared_ptr<ListNode<T> > pL) {
	shared_ptr<ListNode<T> > traverser, opposite, head;
	if (pF->data < pL->data) {
		traverser = pF;
		opposite = pL;
	} else {
		traverser = pL;
		opposite = pF;
	}

	head = traverser;

	while (traverser->next) {
		if (opposite->data < traverser->next->data) {
			auto tmp = traverser->next;
			traverser->next = opposite;
			traverser = opposite;
			opposite = tmp;
		} else
			traverser = traverser->next;
	}

	traverser->next = opposite;
	return head;
}

template <typename T>
void print_list (shared_ptr<ListNode<T> > pList) {
	while (pList) {
		cout << pList->data << endl;
		pList = pList->next;
	}
}

int main () {
	shared_ptr<ListNode<int> > F4(nullptr);
	shared_ptr<ListNode<int> > F3(new_list_node(13, F4));
	shared_ptr<ListNode<int> > F2(new_list_node(10, F3));
	shared_ptr<ListNode<int> > F1(new_list_node(7, F2));
	shared_ptr<ListNode<int> > F0(new_list_node(2, F1));

	shared_ptr<ListNode<int> > L3(nullptr);
	shared_ptr<ListNode<int> > L2(new_list_node(11, L3));
	shared_ptr<ListNode<int> > L1(new_list_node(9, L2));
	shared_ptr<ListNode<int> > L0(new_list_node(1, L1));

	print_list<int>(F0);
	cout << endl;
	print_list<int>(L0);
	cout << endl;

	auto head = Merge(F0, L0);
	print_list<int>(head);

	return 0;
}
```

The solution is `O(n + m)`, where `n` is the size of `L`, and `m` is the size of `F`.

## Book Solution
```C++
template <typename T>
shared_ptr<ListNode<T>> MergeTwoSortedLists (shared_ptr<ListNode<T>> L,
											 shared_ptr<ListNode<T>> F) {
	// Create a placeholder for the result
	shared_ptr<ListNode<T>> dummy_head(new ListNode<int>);
	auto tail = dummy_head;

	while (F && L) {
		AppendNode(F->data < L->data ? &F : &L, &tail);
	}

	// Appends the remaining nodes of F or L
	tail->next = F ? F : L;

	return dummy_head->next;
}

template <typename T>
void AppendNode (shared_ptr<ListNode<T>>* node, shared_ptr<ListNode<T>>* tail) {
	(*tail)->next = *node;
	*tail = *node;  // updates tail
	*node = (*node)->next;
}
```
